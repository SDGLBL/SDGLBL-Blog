---
title: Redis压缩列表的设计与实现
description: 本文深入探讨了Redis压缩列表的设计理念，包括内存布局、节点结构、连锁更新等关键特性。分析了其优势与局限性，并提供了优化建议。
tags:
  - Redis
  - 压缩列表
  - 数据结构
  - data-structures
  - memory-optimization
  - redis-internals
share: "true"
author:
  - SDGLBL
---

# 一、设计哲学：极致的内存优化

> **核心理念**：压缩列表代表了 Redis 对内存优化的极致追求，它通过巧妙的编码方式，将一系列数据紧凑地存储在连续内存中，没有任何冗余空间。

在理解压缩列表之前，我们需要思考一个基本问题：为什么普通的链表会占用那么多内存？

传统链表的内存问题：
1. 每个节点都需要额外的指针字段
2. 内存碎片化，节点分散在内存各处
3. 每个节点都有内存对齐的开销

压缩列表就是为了解决这些问题而生的。它不是一个真正的"列表"，而更像是一个精心设计的字节数组。

# 二、内存布局：艺术般的字节编排

压缩列表在内存中的整体布局如下：

```
<zlbytes><zltail><zllen><entry>...<entry><zlend>
```

让我们详细解析每个字段：

> **zlbytes**: 整个压缩列表占用的字节数（4字节）
> 
> **zltail**: 列表尾部距离列表起始地址的偏移量（4字节）
> 
> **zllen**: 列表中的节点数量（2字节）
> 
> **entry**: 具体的节点内容
> 
> **zlend**: 特殊值 0xFF，标记列表的结束

## 2.1 节点（entry）的精妙设计

每个节点（entry）的结构如下：

```
<prevlen><encoding><data>
```

1. **prevlen**: 前一个节点的长度
   - 如果前一节点长度小于254字节，使用1字节存储
   - 如果大于等于254字节，使用5字节存储（1字节标记位 + 4字节长度）

2. **encoding**: 编码字段，标识数据类型和长度
   - 字符串编码：
     - `00xxxxxx`: 长度小于64字节的字符串
     - `01xxxxxx xxxxxxxx`: 长度小于16384的字符串
     - `10000000 4byte`: 长度小于2^32-1的字符串
   - 整数编码：
     - `11000000`: int16_t
     - `11010000`: int32_t
     - `11100000`: int64_t
     - `11110000`: 24位有符号整数
     - `11111110`: 8位有符号整数
     - `1111xxxx`: 4位无符号整数（0-12）

3. **data**: 实际数据内容

# 三、连锁更新：设计中的权衡

压缩列表最具争议的特性是"连锁更新"（cascade update）现象。这是一种在特定情况下可能发生的连续内存重分配过程。

## 3.1 连锁更新的触发条件

想象以下场景：
1. 有一系列节点，每个节点的长度都是250字节
2. 它们的 prevlen 都使用1字节存储（因为 250 < 254）
3. 现在在某个位置插入一个长度为254字节的节点

会发生什么？

```
原始状态：
[250bytes]  [250bytes]  [250bytes]  [250bytes]
  prevlen:1   prevlen:1   prevlen:1   prevlen:1

插入254字节节点后：
[254bytes]  [250bytes]  [250bytes]  [250bytes]  [250bytes]
             需要5字节     需要5字节    需要5字节    需要5字节
             存储prevlen   存储prevlen  存储prevlen  存储prevlen
```

这就是连锁更新：一个节点的变化可能导致后续节点都需要重新分配内存。

# 四、实际应用：Redis中的角色

Redis在以下场景中使用压缩列表：

1. **小型有序集合（sorted set）**：
   - 元素数量小于128
   - 每个元素的字符串长度小于64字节

2. **小型哈希表**：
   - 键值对数量小于512
   - 所有键值的字符串长度都小于64字节

3. **小型列表**：
   - 在早期版本中用于存储小型列表
   - 现在已被quicklist替代

# 五、实现细节：精巧的编码艺术

## 5.1 压缩列表的创建

```c
unsigned char *ziplistNew(void) {
    unsigned int bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;
    unsigned char *zl = zmalloc(bytes);
    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);
    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);
    ZIPLIST_LENGTH(zl) = 0;
    zl[bytes-1] = ZIP_END;
    return zl;
}
```

## 5.2 节点插入的关键步骤

1. **计算所需空间**：
   - 新节点的数据长度
   - 编码字段的长度
   - prevlen字段的长度

2. **重分配内存**：
   - 考虑连锁更新的可能性
   - 预留足够空间

3. **数据填充**：
   - 编码数据类型和长度
   - 复制数据内容
   - 更新相关指针

# 六、性能特征与最佳实践

## 6.1 优势

1. **内存效率**：
   - 节省了指针开销
   - 减少内存碎片
   - 利用整数编码优化

2. **缓存友好**：
   - 连续内存布局
   - 更好的空间局部性

## 6.2 局限性

1. **连锁更新风险**：
   - 最坏情况下的时间复杂度为O(N)
   - 可能导致性能抖动

2. **容量限制**：
   - 节点数量限制（2^16-1）
   - 总字节数限制（2^32-1）

# 七、实践建议

1. **合理使用阈值**：
   - 密切关注数据规模
   - 及时转换数据结构

2. **监控性能**：
   - 观察内存使用情况
   - 警惕连锁更新

3. **优化策略**：
   - 预估数据增长
   - 合理设置初始容量

压缩列表是Redis中一个极其精妙的数据结构，它通过复杂的编码和精心的内存布局，实现了令人印象深刻的内存优化。理解它的工作原理，不仅能帮助我们更好地使用Redis，也能为我们自己的系统设计提供宝贵的启发。